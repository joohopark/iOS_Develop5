# 40_17-10-31

---

## ARC 

--

## 메모리 관리 방식

- 명시적 해제: 모든것을 개발자가 관리함

- 가비지콜렉터 : 가비지 콜렉터가 수시로 확인해서 안쓰는 객체를 해제 시킴(시스템 성능을 저하 시킨다)

- 레퍼런스 카운팅: 오너쉽 정책에 의해 객체의 해제를 정의
--

## ARC

alloc 과 retain 을 사용해서, 해당 변수를 메모리로 올리거나, 메모리에서 끌어내리거나 할수 있습니다. 

Obecjtive-c에서 인스턴스를 넣었을때 Referene Count가 증가하지 않음, 명령어로 명시적으로 표현해주어야함. 참조는 하는데 Reference Count가 증가하지 않음. 

메모리를 직접적으로 관리 한다면 성능이 증가 시킬수 있음. 


```swift

NSString *str1 = [[NSString alloc] init];
NSString *str2 = [[NSString alloc] init];
NSString *str3 = [[NSString alloc] init];
str2 = [[NSString alloc] init];
[str1 release];
[str2 release];
[str3 release];


```

> 기본적으로 alloc이 되면, release로 사용시점이 종료되면 메모리에서 해제가 되어야 하는데, 위의 코드는, str2가 alloc을 두번 정의하면서, 처음에 생성한 alloc이 str2가 release되는 시점에서 모두 해제가 되어야 하는데, 초기에 생성한 alloc이 해제가 되지 못하고 좀비가 되었다...
> 
 
---

## ARC 도입 이유 

- 앱의 비정상 종료 원인 중 많은 부분이 메모리 문제. 메모리 관리는 애플의 앱 승인 거부(Rejection)의 대다수 원인 중 하나.

- 많은 개발자들이 수동적인(retain/release) 메모리 관리로 힘들어함

- retain/release 로 코드 복잡도가 증가 

> 위의 이유 때문에, 메모리에 대한 이슈를 줄이기 위해서 ARC 도입!

---

## ARC

- ARC는 Automatic Reference Counting의 약자로 기존에 수동 (MRC라고 함)으로 개발자가 직접 retain/release를 통해 reference counting을 관리해야 하는 부분을 자동으로 해준다

---

## ARC 규칙

- 구조체내의 객체 포인트를 사용할 수 없다. 

- id나 void * type을 직접 형변환 시킬 수 없다. 

- NSAutoreleasePool 객체를 사용할수 없다.


---

## 할당

#### - 새로운 키워드 strong, weak


| strong | weak |
| :----: | :----: |
| ![screenc](/study/image/ARC.jpg) | ![screenc](/study/image/ARC-1.jpg) | 

> swift 에서 변수를 선언하면 기본적으로 strong 으로 선언이 된다. weak 를 사용하면, ref count 를 올리지 않고 값만 참조 합니다.. 
> 


#### - 예제 코드 


```swift


class testARC {
    var variable = 10
    
    
    init() {
    }
    
    
    deinit {
        print("인스턴스 해제")
    }
}


var x: testARC? = testARC() // 인스턴스 생성
x?.variable = 10

var a = x // a 인스턴스가 x 인스턴스 강한 참조

weak var b = a // b가 a 인스턴스 약한 참조

print(x, a, b) // x, a, b 는 모드 testARC 의 인스턴스

dump(x) // x는 testARC의 인스턴스 
dump(a) // a는 testARC의 인스턴스 
dump(b) // b는 testARC의 인스턴스 

//
//weak var c: testARC? = testARC() // weak 하나만으로 인스턴스가 생성이 안됨 생성 -> 바로 해제


x = nil // x에 nil 을 넣으면, x와 a 가 같이 참조하던 ref count 가 2->1 로 변합니다. 이때는 x는 nil, a 와 b 는 testARC 의 인스턴스로 아직 살아있습니다.

a = nil // a에 nil을 넣게 되면, x,a가 참조하는 인스턴스의 ref count 가 0 이 되면서 인스턴스가 소멸하게 되고, 자동으로 b는 nil이 됩니다.


print(x,a,b) // nil, nil, nil

dump(x) nil
dump(a) nil
dump(b) nil
```

---

## 순환참조

![screenc](/study/image/ARC-2.jpg) 

| 1 | 2 | 3 |
| :----: | :----: | :----: |
| ![screenc](/study/image/ARC-2.jpg) | ![screenc](/study/image/ARC-3.jpg) | ![screenc](/study/image/ARC-4.jpg) | 

> 순환참조의 문제점은 객체1 의 인스턴스를 삭제해도, 객체 2의 ref count가 2라서, 객체1 소멸, 객체 2,3,4,5 모두 살아 있게되고, 어디에서도 해제를 시킬수 없는 사태가 발생한다. 이를 해결하기 위해서 `weak` 참조를 사용해서 마지막 memory 의 ref count를 1로 만든다.
> 





스토리보드에서, IBOutlet을 하게되면 디폴트 값으로 weak 를 가져오는데, 그 이유는 `addsubView` 에 있다..?


스토리보드도 결국에는 인스턴스 이고 storyboard 도 결국 인스턴스를 생성 시키기 때문에, UIView에 인스턴스를 생성 시킨다. 

그래서 스토리보드로 인스턴스를 생성할때와, 그냥 코드로 인스턴스를 생성할때 메모리에 대한것을 고민 해야 될것 같다 `weak, strong`  


weak 가 필요한 부분은 closure의 캡쳐 부분을 사용할때 weak 로 사용하면 좋다.


- 예제코드


```swift

self.view.frame = {

}

closure가 캡쳐를 하게 되면 애초에 Viewcontroller의 인스턴스의 ref 를 1 증가시킴.


```

> closure 를 인스턴스로 사용할때는 weak 를 사용하는개 좋다는게 음... 진짜 의미를 


---

## Unowned vs Weak

- Unowned : 소유권이 없는 참조임을 나타내는 지시어 절대 옵셔널일수 없음 

- Weak : nil 일수도 있다. 

-> Weak 가 무조건 안전하다고 할수 없음. nil을 피한다고 문제가 해결되는것은 아님.. 크러쉬가 나게 해야 하는 부분은 크러쉬를 내주어야 하는 부분이 존재함.. 이 부분은 명확하게 짚고 넘어가자



---



---

## Reference 


[Transitioning to ARC Release Notes](https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226-CH1-SW14)<br>

[About Memory Management](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i)<br>

[Memory Management Programming Guide for Core Foundation](https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i)<br>

[ARC에 대한 설명이 잘 되어있는 blog](http://seorenn.blogspot.kr/2015/01/swift-memory-management-1.html)

---

## UX/UI 특강 


일반적으로 Desgin 이라고 하면, 스케치 하는것을 생각할수 있는데, 설계하는 의미도 있음.. 

HCI(인지공학) 한번 찾아보자

UX - 일종의 법을 어떻게 조금더 쉽게 해줄것인가에 대한 고민들인것 같음..

UI 와 UX 는 서로 상호 보완적인 관계 둘을 설계하려고 하면, 각각 서로의 UI, UX 들을 고려해서 만들어 주어야 할수 있음..







