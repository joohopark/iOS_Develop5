# 42_17-11-6

--

## Thread, Multithread ,GCD(Grand Central Dispatch), DispatchQueue,

![screen](/study/image/thread.jpg)

- 프로세스(Process) <br>
메모리 상에서 실행되는 프로그램(완전히 독립적인 메모리는 가진다)

- 스레드(Thread) <br>
프로세스 내 실행 흐름 단위(데이터, 힙, 코드 영역을 공유)

- 동기(synchronous)<br>
프로그래밍 적을 ㅗ어떤 일이 끝난후 다음 행동을 한 다면 동기방식(대표적으로 queue 같은 처리 방식을 동기 방식이라고 할수 있을것 같다)

- 비동기(Asynchronous) <br>
어떤 일이 끝난것과는 상관없이 다음 행동을 한다면 비동기 방식(하나의 일을 병렬적으로 각각 독립적으로 처리 하는 경우가 비동기 방식이다)

---

## 교착상태(deadlock)

교착상태 란 두개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과 적으로 아무것도 완료되지 못하는 상태를 가리킨다. 

> 교착상태랑, Thread 의 Race Condition 이랑 혼동 되면 안될것 같다!
> 

---

## Multithread

- Thread<br> 
직접 thread를 만들어서 제어 하는 방식

> UI의 속성 변경은 main UI에서 실행해야 한다, 다른 Thread 에서 UI의 속성을 변경하면, 실행 순서를 보장 할수 없고, 알수 없는 오류가 발생할수 있다.

- GCD<br> 
Closer기반의 기법으로 코드 가독성이 좋고 간편하다.

- Operation <br>
GCD기반의 rapper Class. 간단하게 사용가능하고 고수준의 API를 제공한다. 성능이 느린편

- performSelector<br>
Selector를 이용한 방식, ARC이전에 주로 사용한 방식이였으나 GCD이후엔 많이 사용되진 않는다.

- Timer <br> 
간단한 interval Notification를 제공해 주는 Class. 특이 하게도 Timer는 mainLoop에서 실행된다.

> IOS 에서는 MultiThread 를 여러가지 방법으로 사용을 하는데, 위의 방법들로 사용할수 있다.

---

## GCD(Grand Central Dispatch)

예를 들어서, Login button을 눌렀을떄, 많은 양의 데이터 처리를 한후, UI가 변경되어야 한다고 가정 했을때, Login 버튼을 누르면, 많은 양의 데이터를 연산하게 되면, 이후의 처리가 즉각적으로 실행이 되지 않는다. 이런 경우 사용자에게 좋지 않은 UX 를 경험하게 해주는데, 이 경우를 해결 해주는것이 MultiThread, GCD 방식이다. 

* 비동기로 여러작업을 수행시키는 강력하고 쉬운 방법이다. <br>
* System에서 Thread관리를 알아서 해준다. <br>
* dispatch queue를 이용해 작업들을 컨트롤 한다.<br>
* work item : Closure를 활용해서 구현되어 있으며 queue를 생 성할때 꼭 같이 만들어야 한다. <br>
 

```swift

** ViewController 

@IBOutlet weak var LB: UILabel?


@IBAction btnAction(_ sender: UIButton) {

	var value: Int = 0 
	
	for i in 0...100000 {
		value += 1
	
	}

	LB.text = "변해라"

}
-> 이렇게 작성하게되면, 위의 연산이 끝나야 LB의 텍스트가 변하게 된다, 그래서 버튼을 누르게 되면 사실 연산중인데, 멈춘것 처럼 느낄수 있게된다. 이것을 해결하기위한 여러가지 방법이 있는데, 그중 Timer 을 사용할수 있다 Timer 은 main Thread 에서 작동한다



@IBAction func btnAction(_ sender: UIButton) {
        var total = 0
        let t = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { (t) in
            for i in 0...100000{
                total += 1
                print(total)
        }

            self.LB.text = "변해라"
            } 
       }
       
-> 이렇게 button 에 Timer 을 주어서, 그 안에서 많은 값을 연산하게 만들어주면, 그 연산은 독립적인 Thread 에서 하게되고, UI에 대한 값을 변경이 되게 됩니다.       


-> 조건을 주어서 멈추게 Timer 을 멈추게 할수 있다.

            self.LB.text = "변해라"
            
            if self.LB.text == "변해라" {
                t.invalidate()
            }

```

---

## DispatchQueue

* dispatch queue는 GCD의 핵심으로 GCD로 실행한 작어들을 관리하는 queue 이다.<br>
* 모든 dispatch queue는 first-in, first-out 데이터 구조이다.<br>
* Serial Queue와 Concurrent Queue 2종류로 나눌수 있다.

| Serial Queue | Concurrent Queue |
| :-----: | :-----: |
| ![screen](/study/image/thread-1.jpg) | | ![screen](/study/image/thread-2.jpg) |

> MainThread는 Serial Queue 방식이고, Global 은 Concurrent Queue 방식이다.
> 


















어떤 버튼 누르면 -> Label을 변화하게 만들어 줌 -> 그 사이에 엄청 많은 연산이 있다면, Timer을 사용할수 있다. timer를 사용하면, text의 값을 바꾸고, 그 안의 연산을 적용할수 있다.

```swift
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        let startTime = CFAbsoluteTimeGetCurrent()
        
        print(startTime)
    }

    // Thred의 예시
    @IBAction func btnAction(_ sender: UIButton) {
        
        longTimeAction()
        
        LB.text = "변해"
        
    }
    
    func longTimeAction() {
        var total = 0
        Timer.scheduledTimer(withTimeInterval: 1, repeats:true) { (t) in
                self.LB.text = String(total)
                total += 1
        }
     t.invalidate() 메소드를 통해서 멈추어 줄수도 있다.   
    }

```

thread는 하나의 queue이고, 이 하나의 아이템들은 item 들임. work item 은 queue에 줄서 있는 사람들이다.. 

병렬큐는, 하나의 스레드 안에서 멀티 스레드 처럼 작동이 되는것,

동기와 비동기랑 햇갈리지 말자, 동기는 큐처럼 순서대로 실행이 되는것이고, 비동기는 두개의 작업이 완전히 분리되어서 작업이 되어지는것임.

main 스레드는 직렬 큐임 -> 

mainqueu, global, customqueue

```swift
dispatchQueue.main... 등등으로 가져올수 있음.
DispatchQueue.global().sync
b
global은 파라미터로 우선순위를 받을수 있다. 

```

---

Xcode에서 thread 를 나누어서 사용하는 이유는, 결국 연산속도는 싱글스레드나, 여러개수의 스레드나 비슷비슷하지만, 사용자의 인터렉션 처리를 위해서, thread 를 가지고 시점을 분리(?) 시켜서 사용자에게 속도가 빨라진것처럼 느껴지게, 속임수를 쓰는 방법이라고 생각하면 좋을것 같다.


```swift

let op = OperationQueue()
op.addOperation()
```


DispatchQueue.global().async  안에서는, UI를 사용할수 없음, 이유는 UI에 대한것은 main 에서 업데이트 해주어야 함.

```swift
global 에서 UI에 대한 속성을 변경 해주면 안됨. UI에 대한 속성은 main 에서 변경 시켜주어야 함. 근데, global 에서 사용해도, main에서 사용해야함.
```











---

기윤님

마크 프라이스

json formatter 사이트로 퀄리 브레이스{} 

셈플로 api call 을 하게되면 json으로 요청을 하게되면

초기에 api 로 -> openweather의 URL 로 요청을 하면 -> 알라모 파이어를 통해서, json 데이터르 받을수 있습니다.


마크 프라이스라는 사람은 let 으로 파일을 모아놓고 사용함...CLLocation 

자기만의 고유한 key 값을 함께 필요한 data에 URL을 요청하게되면, 우너하는 값을 얻을수 있다.

알라모파이어로 요청을 할때, URL 값으로 보내고, 결과값을 받아서 사용하는것임.. 아.. 그러면 알라모파이어를 안쓸수가 없겠다. 


초기에 설정 api -> openweather URL -> 알라모파이어 


유데미 -> 마크프라이스 


레포에 이슈가 생겼을때, github에서 제공해줌.. 이슈 트레킹. 

github으로 인증하면, 인증하는 방법은 oAuto

데이터는 실시간으로 네트워크 통신을 통해서 가져오게됨..

callbackurl -> 다시 내 앱으로 돌아올수 있게 하는 url

테이블뷰 같지만 사실은 콜렉션 뷰이고, 셀 사이즈를 다시 작성하게 해줍니다. 

---


