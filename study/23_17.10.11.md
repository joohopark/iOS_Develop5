# 23_17.10.11(수)

---

## 10.11 필기

LB -> XML(기본적으로 xcode는 xml 파일로 저장되어 있는 코드를 변환해서 사용하는데,)

NSCoder 가. xml파일을 -> data로 변환을 시켜서, init<coder> 로 파라미터로 받아들여서.

**스토리보드를 이용해서 인스턴스를 만들떄는, NSCoder라는것으로 인해서 인스턴스를 만듬.**


---

- UINavigationController : 가장 많이 쓰임 

- UITapbarController : death 가 같거나, 완전이 다른 경우에 사용한다
	- 대게 커스텀해서 사용하는데, 커스텀하기가 생각보다 까다롭다,

- UISplitViewController :


---

*swift4 랑, IOS11 버전을 체크하는건 다름*

- UINavigationController 
Q : rootViewcontroller를 정해놓으면 그것이 보인다...? 이거 한번 확인해봐야 겠다.

topviewcontroller : stack 의 최상단
visibleViewController : 화면의 최상단.

**기본적으로 navigation의 toolbar는 히든임. 

- RootViewController 는 ViewController 처럼, 혼자서 어떤것을 표현하지 못함. 그래서 그것을 표현하기 위해서 root뷰는 가진다...?

- 네비게이션 바는 영역이고, 

- 네비게이션 바 영역에서 아이템들이 화면 전환될떄마다 바뀐다.. 근데 사실은 그렇게 동작이 되는게 아니라, `네비게이션 바` 영역을 지정하고, 거기에 들어가는 값들은 ViewController 에서 컨트롤 해준다.

storyboard 로 네비게이션 만들기 

editor -> embed in

- code로 navigationController 만들기

storyBoard id = ViewController 

ui어플리케이션, appdelegate 가 만들어짐.? 

사실 main interface에서 메인 storyboard 에서 windows와, UI를 불러와서 load 하는데, 

- tapbar 자체가 rootViewController 자체를 가지고 있지 않아두됨. 왜냐하면 각각의 viewController가 rootView를 가지고 있기 떄문에, navi자체는, 말그대로 navi의 역활만 해주기 때문이다.


- navi는 stackFrema 방식으로 동작하기 떄문에 자료를 pop 이나 push 를 함. 근데 이게 navi 단에서 내부적을 엄밀하게 사라진다.. 그러면 불러오거나 할때 어디서 불러오는거지...?



**네비게이션 한번 다시 만져 보자**

해봐야 하는것, 뷰 컨트롤러 3개를 만들고, 각각 커스텀하게 만드는데, 기본 디폴트 컬러를 가지고 한번 만들어 보자, 그리고 맨 마지막의 버튼은 home 버튼을 만들어서 원래 뷰로 돌아와서 만들어 주면 좋다! 


---

## Protocol 

- Protocol 문법 속에 프로퍼티는 연산 프로퍼티를 사용 해야함


```swift

protocol Runable {

	var regCount: Int {get set}
	-> 프로퍼티를 정의 할때 get, set 을 정의 해주어야 함..?
	
	func run()
	}

class Animal: Flying {
	var wingcount: Int = 0
	var regCount: Int = 0
	func run() {
	}

```

--- 

## 프로토콜을 타입으로 사용이 가능 하다...

아 이 이야기는. 

```swift

protocol Runable { var regCount:Int {get set} func run()
 
 }
 
  : Runable{  //... }
  class Horse: Runable{  //... }
  func racing(animals:[Runable]) -> Runable {
   } 

let winner:Runable = racing(animals: [Dog(),Horse()])

 -> 이런식으로 채택한 프로토콜 자체를 타입으로서 사용이 가능 하다. 
 -> 여기에서 새롭게 보이는게, 인자로 클레스의 인스턴스 자체를 받음. 저렇게 사용하면, 코드의 사용은 가능 하지만, 재사용은 불가능함
 
```

---

## Delegate

Delegate는 view와 viewcontroller 에서 자주 사용이 되는데, 다른 관계에서도 사용이 가능함


```swift

* Delegate 선언부 

프로토콜을 만들고 - > CustomView class 에, delegate라는 변수에 protocol의 타입을 집어넣어서, delegate?.protocol의 함수가 실행되게 구현을 해놓고 

* 우리가 구현을 할때는 

선언부의 타입을 인스턴스로 만들고(선언부의 타입을 인스턴스로 만드는 이유는 프로토콜을 체텍한 델리게이트를 사용하기 위해서) -> let custom 

델리게이트를 사용하는 엄밀한 이유는 view에서 할수 없는 일을 viewController 가 하게 해주기 위해서, 예를 들어서 내가 테이블 뷰를 만드는데, 테이블뷰 내부의 갯수를 몇개로 할까? 에 대한 고민을.. 사용자에게 넘겨주기 위해서 delegate 를 사용했는데, 그 delegate의 원리는 이렇다.

인스턴스를 넣어주는 이유는, nil이느냐 nil이 아니느냐에 따라서 동작을 하는데, 이때 self를 넣어주는게 되면 선언부에 있는, delegate? 부분이 nil이면 실행이 되지 않고, 

```

---


## 필기 이어서 가져오기

- app을 실행하게 되면 
		 	↓          → MainUI(언제든지 바꾸어 줄수 있다.) -> Viewcontroller
		 						스토리 보드에 있는 UI를 통해서 인스턴스가 만들어 졌다...?
		 						이것을 통해서 View가 만들어지고..
		 						ViewController 가 view에 만들어진 녀석들이 컨트롤 되려고 								하면, 그 이전에 View들이 먼저 만들어지고, 그다음에 								ViewController 가 이녀석들을 컨트롤 할수 있어야 호출이 되어								야 함. 이때 호출되는 녀석이 Viewdidload 
		 						
		 						storyboard 는 UI들을 한눈에 파악하기 위해서 만들어놓은...?
		 						
		 						`rootView`는 Viewdidload 에 만들어져 있다.. 우리는 코드								로 rootView를 만들지 않았어도, 사실은 만들어 져있다...
		 						
		 						`override` 가 호출이 됬을떄는, UIViewController 가 호								출을 하는것임. 그래서 super.viewDidLoad()다...? 뭐지
- UIapplecation
			↓
- Appdelegate


- XiB 파일을 만들어서, MVC 와 다른 분할된것들을 Storyboard 를 만들어서 관리하게 해준것임. 

- 그래서 사실 우리가 UIViewController 에서 MVC의 모든것을 사용 한다고 생각하는데, 사실은 UIViewController 가 `rootView`를 가지고 있기때문에, View와 Viewcontroller 의 경계가 사실 겹쳐 있음.. 

- 그래서 사실 apple이 지원 해주는것은, storyBoard를 View의 역활을 하게 만들고, IBOutlet을 통해서, UIViewController는 는 UI의 컨트롤러 역활만 해주자 라는 이야기..?

---







 