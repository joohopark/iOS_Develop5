# 36_17-10-25

---

## Subscript, Extensions

---

subscript를 통해서 연산 프로퍼티를 실행하는 용도로 사용할수 있다. subscript 문법 자체가 class, struct에서 정의 되어 사용되어 질때 인덱스의 `형태`로 사용되어 질수 있고, 조금더 사람이 생각하는 의미를 전달할수 있게 되어진다.

```swift

class TestSubscript {
        subscript(x: Int, y: Int) -> (Int, Int){
            
            return (x, y)
            
        }
        
    }


var variable = TestSubscript()

print(variable[0,10]) // (0, 10)

**응용**

**subscript 를 사용해보자**

class test {
        subscript(section: Int, row: Int) -> Int {
            if section == 0 {
                if row == 0 {
                    return 0
                }else if row == 1 {
                    return 1
                }else if row == 2 {
                    return 2
                }
                
            }
            return 0
        }
        
        
    }

var x: test() 

x[0,0] // 0 반환 

이런식으로 반환형식을 만들어서 사용할수 있다.


```

---


## Extensions


**Extentsion에서는 저장프로퍼티는 사용할수 없다.**

**Extension**을 통해서, class 내부에 있는 함수들을 기능 별로 나누어서 정리해서 사용하면 조금더 유의미하게 사용할수 있을것 같음..!

- 예제

```swift

delegate, datasource 를 Extension 으로 정리해주어서 사용해도 좋다. 


```



---

## Generic 

모든 타입이 대응이 가능하게 타입의 플레이스 홀더..?


어레나, 딕셔너리는 일단 제네릭이다.

Generic 을 이용해서, Stack, Queue 를 만들어서 사용한다. 

```swift

import Foundation

// 아래의 스텍은 Int 형 밖에 사용이 불가능하다.
//struct Stack {
//
//    private var stackTemp: [Int] = []
//    mutating func push(_ data:Int) {
//
//        self.stackTemp.append(data)
//
//    }
//
//    mutating func pop() -> Int {
//
//        return self.stackTemp.removeLast()
//
//    }
//}


// 제네릭은 하나의 타입처럼 사용이 가능한것 같다. 제네릭자체가 그 후나의 타입으로 정의 되어서 어떤 자료값이든 대응이 가능하게 해놓은것 같음..
struct Stack<j> {
    
    private var stackTemp: [j] = []
    mutating func push(_ data:j) {
        
        self.stackTemp.append(data)
        
    }
    
    mutating func pop() -> j {
        
        return self.stackTemp.removeLast()
        
    }
}


struct Queue<j> {
    private var queueTemp: [j] = []
    
    mutating func inqueue(_ data:j) {
        
        self.queueTemp.append(data)
    }
    
    mutating func dequeue() -> j {
        
        return self.queueTemp.remove(at: 0)
    }
}


class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 이렇게 사용이되면, Int타입을 넣어서 사용할수 있고.
        let stack = Stack<Int>()
        
        // 이렇게 사용하면, 스트링 으로 사용이 가능하다.
        let stack1 = Stack<String>()
        
      
        var qu = Queue<Int>()
        
        qu.inqueue(1)
        qu.inqueue(2)
        qu.inqueue(3)
        qu.inqueue(4)
        
        print(qu.dequeue())
     
    }
}




```

---


## UIImagePickerController

**UIImagePickerController**는 navigationController 를 상속받아서, rootView 사용이안됨... 

사진첩	을 거스텀하게 사용하고 싶으면,

import Photos를 사용 하면 된다...

imageView에 imageView에 넣으면안되는 사이즈..