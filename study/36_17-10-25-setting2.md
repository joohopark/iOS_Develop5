# 36_17-10-25

---

## 코드확장 및 필기

---

## Subscript 

subscript를 통해서 연산 프로퍼티를 실행하는 용도로 사용할수 있을것 같다..? 

subscript 문법 자체가, 초기화 시킬때, 저장하려고 하는 인덱스의 `형태`를 바꾸어 줄수 있음..!

그래서 우리가 보기 편하게 좌표평면 형식으로 표현이 가능하다..!

```swift

**subscript 를 사용해보자**

class test {
        subscript(section: Int, row: Int) -> Int {
            if section == 0 {
                if row == 0 {
                    return 0
                }else if row == 1 {
                    return 1
                }else if row == 2 {
                    return 2
                }
                
            }
            return 0
        }
        
        
    }

var x: test() 

x[0,0] // 0 반환 

이런식으로 반환형식을 만들어서 사용할수 있다.




```


---

## Extensions


** Extentsion에서는 저장프로퍼티는 사용할수 없다.

Delegate, Datasource 를 Extension를 Extension 안에 넣어서 code를 정리해서 사용할수 있다. 

private : class의 범주에서만 사용가능

file private 는 file 내에서

**Extension**을 통해서, class 내부에 있는 함수들을 기능 별로 나누어서 정리해서 사용하면 조금더 유의미하게 사용할수 있을것 같음..!



---

## Generic 

모든 타입이 대응이 가능하게 타입의 플레이스 홀더..?


어레나, 딕셔너리는 일단 제네릭이다.

Generic 을 이용해서, Stack, Queue 를 만들어서 사용한다. 

```swift

import Foundation

// 아래의 스텍은 Int 형 밖에 사용이 불가능하다.
//struct Stack {
//
//    private var stackTemp: [Int] = []
//    mutating func push(_ data:Int) {
//
//        self.stackTemp.append(data)
//
//    }
//
//    mutating func pop() -> Int {
//
//        return self.stackTemp.removeLast()
//
//    }
//}


// 제네릭은 하나의 타입처럼 사용이 가능한것 같다. 제네릭자체가 그 후나의 타입으로 정의 되어서 어떤 자료값이든 대응이 가능하게 해놓은것 같음..
struct Stack<j> {
    
    private var stackTemp: [j] = []
    mutating func push(_ data:j) {
        
        self.stackTemp.append(data)
        
    }
    
    mutating func pop() -> j {
        
        return self.stackTemp.removeLast()
        
    }
}


struct Queue<j> {
    private var queueTemp: [j] = []
    
    mutating func inqueue(_ data:j) {
        
        self.queueTemp.append(data)
    }
    
    mutating func dequeue() -> j {
        
        return self.queueTemp.remove(at: 0)
    }
}


class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        // 이렇게 사용이되면, Int타입을 넣어서 사용할수 있고.
        let stack = Stack<Int>()
        
        // 이렇게 사용하면, 스트링 으로 사용이 가능하다.
        let stack1 = Stack<String>()
        
      
        var qu = Queue<Int>()
        
        qu.inqueue(1)
        qu.inqueue(2)
        qu.inqueue(3)
        qu.inqueue(4)
        
        print(qu.dequeue())
     
    }
}




```

---


## UIImagePickerController

**UIImagePickerController**는 navigationController 를 상속받아서, rootView 사용이안됨... 