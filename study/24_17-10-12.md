# 24_17.10.12(목)
---

## Protocol, Delegate Pattern, AutoLayOut, 

---

## Protocol 

- Protocol 문법 속에 프로퍼티는 연산 프로퍼티를 사용 해야함


```swift

protocol Runable {

	var regCount: Int {get set}
	-> 프로퍼티를 정의 할때 get, set 을 정의 해주어야 함..?
	
	func run()
	}

class Animal: Flying {
	var wingcount: Int = 0
	var regCount: Int = 0
	func run() {
	}

```

--- 

## 프로토콜을 타입으로 사용이 가능 하다...

아 이 이야기는. 

```swift

protocol Runable { var regCount:Int {get set} func run()
 
 }
 
  : Runable{  //... }
  class Horse: Runable{  //... }
  func racing(animals:[Runable]) -> Runable {
   } 

let winner:Runable = racing(animals: [Dog(),Horse()])

 -> 이런식으로 채택한 프로토콜 자체를 타입으로서 사용이 가능 하다. 
 -> 여기에서 새롭게 보이는게, 인자로 클레스의 인스턴스 자체를 받음. 저렇게 사용하면, 코드의 사용은 가능 하지만, 재사용은 불가능함
 
```

---

## Delegate

Delegate는 view와 viewcontroller 에서 자주 사용이 되는데, 다른 관계에서도 사용이 가능함


```swift

* Delegate 선언부 

프로토콜을 만들고 - > CustomView class 에, delegate라는 변수에 protocol의 타입을 집어넣어서, delegate?.protocol의 함수가 실행되게 구현을 해놓고 

* 우리가 구현을 할때는 

선언부의 타입을 인스턴스로 만들고(선언부의 타입을 인스턴스로 만드는 이유는 프로토콜을 체텍한 델리게이트를 사용하기 위해서) -> let custom 

델리게이트를 사용하는 엄밀한 이유는 view에서 할수 없는 일을 viewController 가 하게 해주기 위해서, 예를 들어서 내가 테이블 뷰를 만드는데, 테이블뷰 내부의 갯수를 몇개로 할까? 에 대한 고민을.. 사용자에게 넘겨주기 위해서 delegate 를 사용했는데, 그 delegate의 원리는 이렇다.

인스턴스를 넣어주는 이유는, nil이느냐 nil이 아니느냐에 따라서 동작을 하는데, 이때 self를 넣어주는게 되면 선언부에 있는, delegate? 부분이 nil이면 실행이 되지 않고, 

```

---


## 필기 이어서 가져오기

---







 
## Delegate

CustomView class 생성 -> 스토리보드 파일에, view를 만들고 그 view이름을 CustomView로 만듬. -> 그리고, ViewController에 와서, CustomView 타입의 변수를 만들어서, 그 변수 안에 들어있는 매소드를 가지고 컨트롤함... 이때 CustomView가 되어있는 View안에들어 있는 매소드 들을 실행해서, 그 안에 있는 것들을 바꾸어 줌...


- Delgate 라는 변수와, 그 기능을 생각해보면, 프로토콜을 채택한 Delegate가 실행이 되기 위해서, 어떤 값을 넣어야지, 실행이됨. -> 이거 한번 확인 해보자.

- 프로토콜의 값들을 내가 한번 작성해서 다시 만들어보자! ->

---

## Autolayout

Constraint 를 잘 주어야함... 약간의 수학적인 생각이 필요한것 같다.

- Attribute 값을 잘 알고 있어야함 
	- 이미지를 잘보자

오토 레이아웃을 고려할때, 각각의 값을 

- Layout margin 
	- margin : 디폴트 값이라고 생각해야함.. 음.. margin에 값을 넣어 주게 되면, margin 을 준 값만큼, 떨어진 값이 들어감. 

	- view와 view와의 관계에서 마진을 사용하는 것이 좋음..

 